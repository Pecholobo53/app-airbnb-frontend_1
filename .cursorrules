# REGLAS PARA PROYECTO AIRBNB - STACK ACTUAL COMPLETO

## ğŸ¯ PRINCIPIOS FUNDAMENTALES
1. NUNCA agregues funcionalidades que no he pedido explÃ­citamente
2. USA lo que ya tenemos instalado, NO agregues mÃ¡s librerÃ­as
3. MANTÃ‰N el cÃ³digo simple aunque uses TypeScript
4. NO sobre-compliques con tipos TypeScript innecesarios
5. EXPLICA cada cambio en espaÃ±ol simple

## ğŸ“š STACK ACTUAL PERMITIDO (YA INSTALADO)
- TypeScript 5.2.2 - Ãšsalo pero simple
- Next.js 13.5.1 - App Router
- React 18.2.0
- Tailwind CSS 3.3.3
- Radix UI - Para componentes (dropdown, dialog, etc.)
- React Hook Form - Para formularios
- Zod - Para validaciÃ³n SIMPLE
- Lucide React - Para iconos
- Sonner - Para notificaciones
- date-fns - Para fechas

## â›” NO AGREGUES
1. NO instales mÃ¡s dependencias sin preguntarme
2. NO uses Context API o Redux (usa useState)
3. NO agregues mÃ¡s librerÃ­as de UI
4. NO uses CSS Modules o styled-components
5. NO implementes testing automÃ¡tico
6. NO agregues Storybook
7. NO uses tRPC o GraphQL
8. NO agregues mÃ¡s herramientas de build

## ğŸ“ REGLAS DE TYPESCRIPT
1. Tipos simples - no generics complejos
2. Interfaces antes que types cuando sea posible
3. NO uses 'any' pero tampoco sobre-tipees
4. Tipos explÃ­citos solo cuando TypeScript no pueda inferir
5. NO hagas tipos para TODO, solo lo necesario
```typescript
// âœ… BIEN - Simple y claro
interface User {
  id: string
  name: string
  email: string
}

// âŒ MAL - Demasiado complejo
type ComplexGeneric<T extends BaseType<K>, K = string> = ...
```

## ğŸ¨ COMPONENTES CON RADIX UI
1. USA Radix UI que ya tienes para modales, dropdowns, etc.
2. NO personalices demasiado los componentes Radix
3. Estiliza con Tailwind, no con CSS custom
4. MantÃ©n la accesibilidad que Radix provee
```tsx
// âœ… BIEN - Simple con Radix
<Dialog.Root>
  <Dialog.Trigger className="btn-primary">Abrir</Dialog.Trigger>
  <Dialog.Content className="bg-white p-6 rounded-lg">
    Contenido simple
  </Dialog.Content>
</Dialog.Root>
```

## ğŸ“ ESTRUCTURA NEXT.JS 13 APP ROUTER
```
/app
  /page.tsx              (pÃ¡gina principal)
  /layout.tsx            (layout principal)
  /(auth)
    /login/page.tsx      (pÃ¡ginas de auth)
    /register/page.tsx
  /(dashboard)
    /propiedades/page.tsx
    /reservas/page.tsx
  /api
    /auth/[...nextauth]/route.ts
    /propiedades/route.ts
/components
  /ui                    (componentes Radix/bÃ¡sicos)
  /forms                 (formularios con react-hook-form)
  /features              (componentes de negocio)
  /layout                (headers, footers)
/lib
  /utils.ts              (funciones auxiliares)
  /constants.ts          (configuraciÃ³n centralizada)
  /db.ts                 (conexiÃ³n a base de datos)
  /api/                  (funciones de API)
/hooks
  /use-auth.ts           (hooks personalizados)
  /use-property.ts
/types
  /index.ts              (tipos TypeScript globales)
```

## ğŸ”„ REFACTORIZACIÃ“N Y COMPONENTES REUTILIZABLES

### PRINCIPIO DRY (Don't Repeat Yourself)
1. Si copias cÃ³digo 2 veces â†’ Considera extraerlo
2. Si copias cÃ³digo 3 veces â†’ DEBES extraerlo
3. Un componente reutilizable = Una responsabilidad clara
4. Mejor 5 componentes simples que 1 componente complejo

### JERARQUÃA DE COMPONENTES
```
/components
  /ui                    # Ãtomos - Botones, Inputs, Cards
    Button.tsx
    Input.tsx
    Card.tsx
  /forms                 # MolÃ©culas - Combinan Ã¡tomos
    SearchBar.tsx
    LoginForm.tsx
    PropertyForm.tsx
  /features              # Organismos - Features completas
    PropertyList.tsx
    BookingCalendar.tsx
    ReviewSection.tsx
  /layout                # Templates - Estructuras de pÃ¡gina
    Header.tsx
    Sidebar.tsx
    Footer.tsx
```

## ğŸ’ª ROBUSTEZ Y MANEJO DE ERRORES

### PRINCIPIO FAIL-SAFE
1. Cada componente debe poder fallar sin romper la app
2. Estados de error claros y recuperables
3. Fallbacks Ãºtiles, no pantallas en blanco
4. Logs claros para debugging

### PATRÃ“N DE COMPONENTE ROBUSTO
```tsx
// âœ… COMPONENTE ROBUSTO
export function PropertyCard({ property }: PropertyCardProps) {
  // Estados para manejar casos edge
  const [imageError, setImageError] = useState(false)
  const [isLoading, setIsLoading] = useState(true)
  
  // Valores por defecto seguros
  const title = property?.title || 'Propiedad sin tÃ­tulo'
  const price = property?.price ?? 0
  const image = property?.image || '/placeholder.jpg'
  
  // Manejo de errores en imagen
  const handleImageError = () => {
    setImageError(true)
    console.error(`Error cargando imagen: ${property?.id}`)
  }
  
  // Loading state
  if (isLoading) {
    return <CardSkeleton />
  }
  
  // Error boundary local
  try {
    return (
      <div className="card">
        <img 
          src={imageError ? '/placeholder.jpg' : image}
          onError={handleImageError}
          alt={title}
        />
        <h3>{title}</h3>
        <p>${price}/noche</p>
      </div>
    )
  } catch (error) {
    console.error('Error en PropertyCard:', error)
    return <CardErrorFallback />
  }
}
```

## ğŸ”§ CONFIGURACIÃ“N EXISTENTE
1. NO modifiques tsconfig.json sin necesidad
2. NO cambies next.config.js a menos que sea crÃ­tico
3. USA las configuraciones de Tailwind que ya existen
4. MANTÃ‰N output: 'export' si estÃ¡ configurado asÃ­

## ğŸ“ FORMULARIOS CON REACT HOOK FORM + ZOD
```tsx
// âœ… BIEN - Simple y funcional
const schema = z.object({
  email: z.string().email('Email invÃ¡lido'),
  password: z.string().min(6, 'MÃ­nimo 6 caracteres')
})

const { register, handleSubmit, formState: { errors } } = useForm({
  resolver: zodResolver(schema)
})

// âŒ MAL - Demasiado complejo
const complexSchema = z.object({...}).transform().refine().superRefine()...
```

## ğŸ¯ REGLAS DE DESARROLLO
1. USA Server Components por defecto en Next.js 13
2. 'use client' SOLO cuando necesites interactividad
3. NO uses getServerSideProps/getStaticProps (usa App Router)
4. Loading.tsx y error.tsx simples
5. NO implementes ISR o configuraciones avanzadas

## ğŸ’¡ COMPONENTES
1. Un componente = Un archivo
2. Props tipadas pero simples
3. NO mÃ¡s de 100 lÃ­neas por componente
4. Divide en componentes mÃ¡s pequeÃ±os si crece
```tsx
// âœ… BIEN
interface ButtonProps {
  onClick: () => void
  children: React.ReactNode
  variant?: 'primary' | 'secondary'
  disabled?: boolean
}

// âŒ MAL
interface ButtonProps extends HTMLButtonElement, 
  React.ButtonHTMLAttributes<HTMLButtonElement>,
  CustomButtonInterface, BaseComponentProps<'button'> {...}
```

## ğŸ—ï¸ ARQUITECTURA ESCALABLE

### SEPARACIÃ“N DE RESPONSABILIDADES
```typescript
// ğŸ“ /lib/api/properties.ts - LÃ³gica de negocio
export async function getProperties(filters?: PropertyFilters) {
  try {
    const response = await fetch('/api/properties', {
      method: 'POST',
      body: JSON.stringify(filters)
    })
    if (!response.ok) throw new Error('Failed to fetch')
    return response.json()
  } catch (error) {
    console.error('Error fetching properties:', error)
    throw error
  }
}

// ğŸ“ /components/features/PropertyList.tsx - PresentaciÃ³n
export function PropertyList() {
  const [properties, setProperties] = useState([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)
  
  useEffect(() => {
    getProperties()
      .then(setProperties)
      .catch((err) => {
        setError(err.message)
        setProperties([]) // Fallback seguro
      })
      .finally(() => setLoading(false))
  }, [])
  
  if (loading) return <PropertyListSkeleton />
  if (error) return <ErrorMessage message={error} />
  
  return (
    <div className="grid grid-cols-3 gap-4">
      {properties.map(p => (
        <PropertyCard key={p.id} property={p} />
      ))}
    </div>
  )
}
```

### CONSTANTES Y CONFIGURACIÃ“N CENTRALIZADA
```typescript
// ğŸ“ /lib/constants.ts
export const APP_CONFIG = {
  MAX_GUESTS: 16,
  MIN_NIGHTS: 1,
  MAX_NIGHTS: 365,
  DEFAULT_CURRENCY: 'EUR',
  IMAGE_FORMATS: ['jpg', 'png', 'webp'],
  ITEMS_PER_PAGE: 12,
} as const

export const API_ENDPOINTS = {
  PROPERTIES: '/api/properties',
  BOOKINGS: '/api/bookings',
  REVIEWS: '/api/reviews',
} as const

export const ERROR_MESSAGES = {
  NETWORK: 'Error de conexiÃ³n. Intenta de nuevo.',
  NOT_FOUND: 'No encontramos lo que buscas.',
  UNAUTHORIZED: 'Necesitas iniciar sesiÃ³n.',
  DEFAULT: 'Algo saliÃ³ mal. Intenta mÃ¡s tarde.',
} as const
```

## ğŸš¨ MANEJO DE ESTADO
1. useState para estado local
2. useReducer SOLO si useState se vuelve muy complejo
3. Props drilling estÃ¡ OK para 2-3 niveles
4. Custom hooks para lÃ³gica compartida
5. Server state con fetch en Server Components

### CUSTOM HOOKS PARA LÃ“GICA COMPARTIDA
```tsx
// hooks/usePropertySearch.ts
export function usePropertySearch() {
  const [results, setResults] = useState([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)
  
  const search = async (query: string) => {
    setLoading(true)
    setError(null)
    try {
      const data = await fetch(`/api/search?q=${query}`)
      if (!data.ok) throw new Error('Error en bÃºsqueda')
      setResults(await data.json())
    } catch (err) {
      setError(err.message)
      setResults([])
    } finally {
      setLoading(false)
    }
  }
  
  return { results, loading, error, search }
}
```

## ğŸ“¡ API Y DATOS
1. Route Handlers simples en /app/api
2. fetch() nativo, NO axios
3. Prisma para base de datos (si lo agregamos)
4. ValidaciÃ³n con Zod en cliente y servidor
5. SanitizaciÃ³n de datos antes de guardar

## ğŸ¨ ESTILOS CON TAILWIND
1. USA clases de Tailwind estÃ¡ndar
2. cn() helper para clases condicionales
3. NO @apply en CSS a menos que sea necesario
4. NO themes complejos, usa los colores de Tailwind
```tsx
// âœ… BIEN - Clases simples y legibles
<div className="flex items-center justify-between p-4 bg-white rounded-lg shadow">

// âŒ MAL - Demasiadas clases custom
<div className="custom-flex-wrapper theme-card-variant-2 enhanced-shadow">
```

## ğŸ›¡ï¸ VALIDACIÃ“N Y SANITIZACIÃ“N

### VALIDACIÃ“N EN MÃšLTIPLES CAPAS
```typescript
// 1. Cliente - ValidaciÃ³n inmediata
const PropertySchema = z.object({
  title: z.string().min(5, 'MÃ­nimo 5 caracteres').max(100),
  price: z.number().positive('Debe ser mayor a 0'),
  guests: z.number().min(1).max(APP_CONFIG.MAX_GUESTS),
})

// 2. API - Re-validaciÃ³n en servidor
export async function POST(request: Request) {
  const body = await request.json()
  
  const validation = PropertySchema.safeParse(body)
  if (!validation.success) {
    return NextResponse.json(
      { error: validation.error.flatten() },
      { status: 400 }
    )
  }
  
  // Procesar datos validados...
}
```

## ğŸ”§ UTILIDADES REUTILIZABLES

### FUNCIONES HELPER COMUNES
```typescript
// ğŸ“ /lib/utils.ts

// Formateo de precios consistente
export function formatPrice(price: number, currency = 'EUR') {
  return new Intl.NumberFormat('es-ES', {
    style: 'currency',
    currency,
  }).format(price)
}

// Manejo seguro de fechas
export function formatDate(date: string | Date | null) {
  if (!date) return 'Fecha no disponible'
  try {
    return format(new Date(date), 'dd MMM yyyy', { locale: es })
  } catch {
    return 'Fecha invÃ¡lida'
  }
}

// Debounce reutilizable
export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): T {
  let timeout: NodeJS.Timeout
  return ((...args) => {
    clearTimeout(timeout)
    timeout = setTimeout(() => func(...args), wait)
  }) as T
}

// Clase condicional helper (si no tienes cn())
export function cn(...classes: (string | undefined | null | false)[]) {
  return classes.filter(Boolean).join(' ')
}
```

## âš¡ OPTIMIZACIÃ“N
1. NO optimices prematuramente
2. Image de Next.js para imÃ¡genes
3. Link de Next.js para navegaciÃ³n
4. dynamic() SOLO si realmente lo necesitas
5. NO memo/callback en todos lados
6. Lazy loading para componentes pesados
```tsx
// âœ… BIEN - OptimizaciÃ³n necesaria
const HeavyComponent = dynamic(() => import('./HeavyComponent'), {
  loading: () => <Skeleton />,
  ssr: false
})

// âŒ MAL - OptimizaciÃ³n prematura
const SimpleButton = memo(({ onClick, children }) => {
  const handleClick = useCallback(onClick, [onClick])
  return <button onClick={handleClick}>{children}</button>
})
```

## ğŸ“ CHECKLIST DE REFACTORIZACIÃ“N

Antes de considerar cÃ³digo "terminado", verifica:

### âœ… ReutilizaciÃ³n
- [ ] Â¿Hay cÃ³digo duplicado que pueda extraerse?
- [ ] Â¿Los componentes son lo suficientemente genÃ©ricos?
- [ ] Â¿La lÃ³gica de negocio estÃ¡ separada de la UI?

### âœ… Robustez
- [ ] Â¿Maneja estados de loading?
- [ ] Â¿Maneja errores gracefully?
- [ ] Â¿Tiene valores por defecto seguros?
- [ ] Â¿Los tipos TypeScript previenen errores?

### âœ… Mantenibilidad
- [ ] Â¿Es fÃ¡cil entender quÃ© hace el cÃ³digo?
- [ ] Â¿Los nombres son descriptivos?
- [ ] Â¿EstÃ¡ bien organizado en carpetas?
- [ ] Â¿SerÃ­a fÃ¡cil agregar features?

### âœ… Performance (sin obsesionarse)
- [ ] Â¿Se cargan imÃ¡genes de forma optimizada?
- [ ] Â¿Los componentes pesados son lazy-loaded?
- [ ] Â¿Se evitan re-renders innecesarios?

## ğŸ¯ REGLA DE ORO DE REFACTORIZACIÃ“N

**"Primero hazlo funcionar, luego hazlo bonito, finalmente hazlo rÃ¡pido"**

1. **FASE 1:** Implementa la funcionalidad bÃ¡sica
2. **FASE 2:** Refactoriza para reutilizaciÃ³n y claridad
3. **FASE 3:** Optimiza solo si hay problemas reales

## âš ï¸ SEÃ‘ALES PARA REFACTORIZAR

- Archivo con mÃ¡s de 200 lÃ­neas â†’ Dividir
- Componente con mÃ¡s de 5 props â†’ Simplificar
- FunciÃ³n con mÃ¡s de 30 lÃ­neas â†’ Extraer lÃ³gica
- Copy-paste del mismo cÃ³digo 3+ veces â†’ Crear utilidad
- Dificultad para agregar nueva feature â†’ Reorganizar
- Bugs recurrentes en el mismo lugar â†’ Fortalecer validaciÃ³n
- "No toco eso porque se rompe todo" â†’ Refactorizar urgente

## ğŸ”„ ANTES DE CADA RESPUESTA
PregÃºntate:
1. Â¿Estoy usando algo que ya estÃ¡ instalado?
2. Â¿Es la implementaciÃ³n mÃ¡s simple con este stack?
3. Â¿Estoy agregando tipos innecesarios?
4. Â¿Puedo hacerlo con menos cÃ³digo?
5. Â¿Es reutilizable y robusto?
6. Â¿Maneja errores adecuadamente?

## ğŸ“Œ COMANDOS RÃPIDOS
"sin tipos complejos" = tipos bÃ¡sicos de TypeScript
"componente simple" = sin props complejas ni lÃ³gica excesiva
"usa lo que hay" = no instales nada nuevo
"server component" = sin 'use client'
"client component" = con 'use client' y hooks
"formulario bÃ¡sico" = react-hook-form sin validaciones excesivas
"hazlo robusto" = agrega manejo de errores y estados edge
"refactoriza esto" = extrae componentes y lÃ³gica reutilizable
"optimiza" = SOLO si hay un problema real de performance

## ğŸ® EJEMPLO DE USO CORRECTO
```typescript
// âŒ MAL - Cursor siendo demasiado "inteligente"
"Crea un sistema de bÃºsqueda con debounce, virtualizaciÃ³n,
caching distribuido y machine learning"

// âœ… BIEN - Simple, claro y escalable
"Crea un componente de bÃºsqueda que:
1. Busque propiedades por nombre
2. Muestre loading mientras busca
3. Maneje errores si falla
4. Sea reutilizable en otras pÃ¡ginas"
```

## ğŸ’¡ FILOSOFÃA FINAL

**SIMPLICIDAD + ROBUSTEZ = ESCALABILIDAD**

- CÃ³digo simple es mÃ¡s fÃ¡cil de mantener
- CÃ³digo robusto previene bugs futuros
- CÃ³digo reutilizable acelera el desarrollo
- La complejidad debe justificarse con valor real

RECUERDA: No porque tengas TypeScript y librerÃ­as modernas significa que todo debe ser complejo. La elegancia estÃ¡ en la simplicidad.